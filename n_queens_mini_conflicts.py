# -*- coding: utf-8 -*-
"""n_queens_mini-conflicts

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19h4PpAqkIpoN3RT_w2N4JCNX41NkJ3JY
"""

import time
import random
from collections import deque


# Greedy Initialization Function - Optimized
def initialize_board_greedy(n):
    board = [-1] * n  # Start with an empty board
    row_conflicts = [0] * n
    diag1_conflicts = [0] * (2 * n - 1)
    diag2_conflicts = [0] * (2 * n - 1)

    for col in range(n):
        min_conflicts = n
        best_row = 0
        for row in range(n):
            conflicts = (row_conflicts[row] +
                         diag1_conflicts[row - col + n - 1] +
                         diag2_conflicts[row + col])
            if conflicts < min_conflicts:
                min_conflicts = conflicts
                best_row = row

        board[col] = best_row
        row_conflicts[best_row] += 1
        diag1_conflicts[best_row - col + n - 1] += 1
        diag2_conflicts[best_row + col] += 1

    return board


# Optimized Min-Conflicts Local Search with Greedy Initialization
def min_conflicts_optimized(n, max_steps=None):
    max_steps = max_steps or (2 * n if n <= 100 else n * 1.5)
    board = initialize_board_greedy(n)  # Use greedy initialization instead of random

    # Conflict counters for rows and diagonals
    row_conflicts = [0] * n
    diag1_conflicts = [0] * (2 * n - 1)
    diag2_conflicts = [0] * (2 * n - 1)

    # Initialize conflicts based on the greedy board configuration
    for col in range(n):
        row = board[col]
        row_conflicts[row] += 1
        diag1_conflicts[row - col + n - 1] += 1
        diag2_conflicts[row + col] += 1

    tabu_list = deque(maxlen=5)  # Tabu list to avoid recent moves

    def calculate_conflicts(row, col):
        """Calculate number of conflicts for placing queen at (row, col)."""
        return (row_conflicts[row] +
                diag1_conflicts[row - col + n - 1] +
                diag2_conflicts[row + col] - 3)

    for step in range(int(max_steps)):
        # Check if the solution is reached
        total_conflicts = sum(calculate_conflicts(board[col], col) for col in range(n))
        if total_conflicts == 0:
            return board, step  # Solution found

        # Find conflicted columns
        conflicted_cols = [col for col in range(n) if calculate_conflicts(board[col], col) > 0]

        # Pick a random conflicted column to adjust
        col = random.choice(conflicted_cols)

        # Find the row with minimum conflicts in this column
        min_conflict_row = board[col]
        min_conflicts = calculate_conflicts(min_conflict_row, col)

        for row in range(n):
            if row != board[col] and (col, row) not in tabu_list:
                current_conflicts = (row_conflicts[row] +
                                     diag1_conflicts[row - col + n - 1] +
                                     diag2_conflicts[row + col])
                if current_conflicts < min_conflicts:
                    min_conflict_row, min_conflicts = row, current_conflicts
                    if min_conflicts == 0:
                        break  # Early exit if zero conflicts found

        # Move the queen and update the conflict counts
        if min_conflict_row is not None:
            old_row = board[col]
            board[col] = min_conflict_row
            tabu_list.append((col, old_row))  # Add previous position to tabu list

            # Update conflict counts efficiently by incrementing/decrementing
            row_conflicts[old_row] -= 1
            diag1_conflicts[old_row - col + n - 1] -= 1
            diag2_conflicts[old_row + col] -= 1

            row_conflicts[min_conflict_row] += 1
            diag1_conflicts[min_conflict_row - col + n - 1] += 1
            diag2_conflicts[min_conflict_row + col] += 1

    return None, max_steps  # No solution found within max_steps


# Function to measure execution time for the optimized algorithm
def execute_min_conflicts_optimized(n, trials=3):
    total_time = 0
    for _ in range(trials):
        start_time = time.time()
        solution, steps = min_conflicts_optimized(n)
        total_time += (time.time() - start_time)
    return total_time / trials


# Run experiments for values of n up to 1000 and print the results
print("n\tMin-Conflicts Optimized (Average Time)")
for n in range(4, 22000, 500):  # Adjusted range and increment for larger values
    avg_time = execute_min_conflicts_optimized(n)
    print(f"{n}\t{avg_time:.4f}s")