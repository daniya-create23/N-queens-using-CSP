# -*- coding: utf-8 -*-
"""n_queens_using_CSP

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19h4PpAqkIpoN3RT_w2N4JCNX41NkJ3JY
"""

import time
import random

# Helper function to check if a queen placement is safe
def is_safe(board, row, col):
    for i in range(col):
        if board[i] == row or \
           board[i] - i == row - col or \
           board[i] + i == row + col:
            return False
    return True

# 1. Backtracking Solution
def solve_n_queens_backtracking(board, col, n):
    if col >= n:
        return True
    for row in range(n):
        if is_safe(board, row, col):
            board[col] = row
            if solve_n_queens_backtracking(board, col + 1, n):
                return True
            board[col] = -1  # Backtrack
    return False

# 2. Backtracking with Forward Checking
def forward_check(board, col, n, available):
    if col == n:
        return True
    for row in range(n):
        if available[col][row] and is_safe(board, row, col):
            board[col] = row
            backup = [available[i][:] for i in range(n)]
            for i in range(col + 1, n):
                available[i][row] = False
                if row + (i - col) < n:
                    available[i][row + (i - col)] = False
                if row - (i - col) >= 0:
                    available[i][row - (i - col)] = False
            if forward_check(board, col + 1, n, available):
                return True
            board[col] = -1  # Backtrack
            available = backup
    return False

# 3. Backtracking with Forward Checking + MRV and LCV Heuristics
def solve_n_queens_mrv_lcv(board, col, n, available):
    if col == n:
        return True

    # MRV: Select column with fewest available positions
    next_col = min((i for i in range(col, n) if board[i] == -1),
                   key=lambda c: sum(available[c]), default=col)

    # LCV: Sort rows by least-constraining-value heuristic
    row_options = sorted(range(n), key=lambda r: sum(available[i][r] for i in range(next_col + 1, n)))

    for row in row_options:
        if available[next_col][row] and is_safe(board, row, next_col):
            board[next_col] = row
            backup = [available[i][:] for i in range(n)]
            for i in range(next_col + 1, n):
                available[i][row] = False
                if row + (i - next_col) < n:
                    available[i][row + (i - next_col)] = False
                if row - (i - next_col) >= 0:
                    available[i][row - (i - next_col)] = False
            if solve_n_queens_mrv_lcv(board, col + 1, n, available):
                return True
            board[next_col] = -1  # Backtrack
            available = backup
    return False

# Function to measure execution time for each algorithm
def execute_backtracking_algorithms(n, trials=5):
    # Store average times across multiple trials for stability
    backtracking_time, forward_check_time, mrv_lcv_time = 0, 0, 0

    # 1. Backtracking
    for _ in range(trials):
        board = [-1] * n
        start_time = time.time()
        solve_n_queens_backtracking(board, 0, n)
        backtracking_time += (time.time() - start_time)

    # 2. Backtracking with Forward Checking
    for _ in range(trials):
        board = [-1] * n
        available = [[True] * n for _ in range(n)]
        start_time = time.time()
        forward_check(board, 0, n, available)
        forward_check_time += (time.time() - start_time)

    # 3. Backtracking with MRV + LCV
    for _ in range(trials):
        board = [-1] * n
        available = [[True] * n for _ in range(n)]
        start_time = time.time()
        solve_n_queens_mrv_lcv(board, 0, n, available)
        mrv_lcv_time += (time.time() - start_time)

    # Compute average times
    return backtracking_time / trials, forward_check_time / trials, mrv_lcv_time / trials

# Run experiments for values of n and construct the results table
print("n\tBacktracking\tForward Checking\tMRV + LCV")
for n in range(4, 39):  # Adjust range for larger values as computational resources allow
    times = execute_backtracking_algorithms(n)
    print(f"{n}\t{times[0]:.4f}s\t\t{times[1]:.4f}s\t\t{times[2]:.4f}s")